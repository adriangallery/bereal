<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Swap de Prueba con Debug - Universal Router V4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    input, select, button { margin-bottom: 10px; }
    pre { background: #eee; padding: 10px; max-height: 300px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Swap de Prueba con Debug</h1>
  <p id="walletStatus">Wallet no conectada.</p>
  
  <label for="swapDirection">Selecciona la dirección del swap:</label>
  <select id="swapDirection">
    <option value="sell" selected>Vender ADRIAN por ETH</option>
    <option value="buy">Comprar ADRIAN con ETH</option>
  </select>
  <br>
  
  <label for="swapAmount">Cantidad (para "sell": ADRIAN, para "buy": ETH):</label>
  <input type="number" id="swapAmount" placeholder="Cantidad" step="any" min="0">
  <br>
  
  <button id="swapBtn">Ejecutar Swap</button>
  
  <h3>Debug Logs</h3>
  <pre id="debugLog"></pre>
  
  <script>
    /**************** CONFIGURACIÓN ****************/
    // Direcciones conocidas
    const routerAddress = "0x6fF5693b99212Da76ad316178A184AB56D299b43"; // Universal Router V4
    const pairAddress = "0x95EBfcb1c6b345fdA69cF56C51E30421e5a35aeC"; // Contrato de la pareja ADRIAN/WETH
    const adrianTokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea"; // Token ADRIAN
    const WETHAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";    // WETH (Mainnet)
    
    // ABI mínimo del Universal Router V4 (solo la función execute)
    const routerABI = [
      "function execute(tuple(address target, uint256 value, bytes data, bool allowFailure)[] calls, address to, uint256 deadline) external payable returns (bytes[] memory results)"
    ];
    
    // ABI mínimo del par (para token0, token1, getReserves y swap)
    const pairABI = [
      "function token0() view returns (address)",
      "function token1() view returns (address)",
      "function getReserves() view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)",
      "function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external"
    ];
    
    // ABI mínimo para ERC20 (aprobación y allowance)
    const erc20ABI = [
      "function approve(address spender, uint256 amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    
    let provider, signer, userAddress;
    let routerContract, pairContract, adrianTokenContract;
    let token0, token1;
    
    const debugLogElem = document.getElementById("debugLog");
    function logDebug(msg) {
      console.log(msg);
      debugLogElem.textContent += msg + "\n";
    }
    
    /**************** CONEXIÓN DE WALLET ****************/
    async function connectWallet() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        document.getElementById("walletStatus").innerText = "Wallet conectada: " + userAddress;
        logDebug("Wallet conectada: " + userAddress);
        
        // Instanciar contratos
        routerContract = new ethers.Contract(routerAddress, routerABI, signer);
        pairContract = new ethers.Contract(pairAddress, pairABI, provider);
        adrianTokenContract = new ethers.Contract(adrianTokenAddress, erc20ABI, signer);
        
        // Consultar token0 y token1 del par
        token0 = (await pairContract.token0()).toLowerCase();
        token1 = (await pairContract.token1()).toLowerCase();
        logDebug("token0: " + token0);
        logDebug("token1: " + token1);
      } else {
        alert("Instala MetaMask.");
      }
    }
    
    /**************** FUNCIONES AUXILIARES ****************/
    // Función para calcular el monto de salida según la fórmula de Uniswap (fee 0.3%)
    function getAmountOut(amountIn, reserveIn, reserveOut) {
      const amountInWithFee = amountIn.mul(997);
      const numerator = amountInWithFee.mul(reserveOut);
      const denominator = reserveIn.mul(1000).add(amountInWithFee);
      return numerator.div(denominator);
    }
    
    /**************** FUNCION DE SWAP ****************/
    async function performSwap() {
      const direction = document.getElementById("swapDirection").value; // "sell" o "buy"
      const swapAmount = document.getElementById("swapAmount").value;
      if (!swapAmount || Number(swapAmount) <= 0) {
        logDebug("Cantidad inválida");
        return;
      }
      // Deadline a 20 minutos desde ahora
      const deadline = Math.floor(Date.now() / 1000) + (20 * 60);
      
      let amountIn, expectedOut, amount0Out, amount1Out, valueToSend;
      valueToSend = ethers.BigNumber.from(0);
      
      // Consultar reservas
      const reserves = await pairContract.getReserves();
      const reserve0 = ethers.BigNumber.from(reserves._reserve0);
      const reserve1 = ethers.BigNumber.from(reserves._reserve1);
      logDebug("Reserves: reserve0=" + reserve0.toString() + ", reserve1=" + reserve1.toString());
      
      if (direction === "sell") {
        // Vender ADRIAN por ETH
        amountIn = ethers.utils.parseUnits(swapAmount, 18);
        logDebug("Sell: amountIn (ADRIAN): " + amountIn.toString());
        
        // Aprobar tokens ADRIAN al router, si es necesario
        const allowance = await adrianTokenContract.allowance(userAddress, routerAddress);
        logDebug("Allowance: " + allowance.toString());
        if (allowance.lt(amountIn)) {
          logDebug("Aprobando tokens ADRIAN...");
          const approveTx = await adrianTokenContract.approve(routerAddress, ethers.constants.MaxUint256);
          await approveTx.wait();
          logDebug("Tokens aprobados.");
        }
        
        // Si ADRIAN es token0, se vende token0 para obtener token1 (WETH)
        if (token0 === adrianTokenAddress.toLowerCase()) {
          expectedOut = getAmountOut(amountIn, reserve0, reserve1);
          amount0Out = ethers.BigNumber.from(0);
          amount1Out = expectedOut;
          logDebug("Expected WETH out: " + expectedOut.toString());
        } else {
          // Si ADRIAN es token1
          expectedOut = getAmountOut(amountIn, reserve1, reserve0);
          amount0Out = expectedOut;
          amount1Out = ethers.BigNumber.from(0);
          logDebug("Expected WETH out: " + expectedOut.toString());
        }
      } else {
        // Comprar ADRIAN con ETH
        amountIn = ethers.utils.parseUnits(swapAmount, 18); // ETH a invertir
        valueToSend = amountIn;
        logDebug("Buy: amountIn (ETH): " + amountIn.toString());
        if (token0 === adrianTokenAddress.toLowerCase()) {
          expectedOut = getAmountOut(amountIn, reserve1, reserve0);
          amount0Out = expectedOut;
          amount1Out = ethers.BigNumber.from(0);
          logDebug("Expected ADRIAN out: " + expectedOut.toString());
        } else {
          expectedOut = getAmountOut(amountIn, reserve0, reserve1);
          amount0Out = ethers.BigNumber.from(0);
          amount1Out = expectedOut;
          logDebug("Expected ADRIAN out: " + expectedOut.toString());
        }
      }
      
      // Codificar la llamada al método swap del par
      const swapData = pairContract.interface.encodeFunctionData("swap", [
        amount0Out, amount1Out, userAddress, "0x"
      ]);
      logDebug("swapData: " + swapData);
      
      // Construir el objeto call para la función execute
      const callObject = {
        target: pairAddress,
        value: valueToSend,
        data: swapData,
        allowFailure: false
      };
      logDebug("Call object: " + JSON.stringify(callObject));
      
      try {
        logDebug("Ejecutando execute en el router...");
        const tx = await routerContract.execute([callObject], userAddress, deadline, {
          value: valueToSend,
          gasLimit: 600000
        });
        logDebug("Tx enviada: " + tx.hash);
        const receipt = await tx.wait();
        logDebug("Tx confirmada. Receipt: " + JSON.stringify(receipt));
      } catch (error) {
        logDebug("Error en execute: " + error);
        console.error(error);
      }
    }
    
    /**************** EVENTOS ****************/
    document.getElementById("swapBtn").addEventListener("click", performSwap);
    window.addEventListener("load", connectWallet);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="https://files.catbox.moe/ffvdjy.svg" type="image/svg+xml">
  <meta charset="UTF-8">
  <title>$ADRIAN marketplace</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Custom Styles -->
  <style>
    /* ========== GLOBAL STYLES ========== */
    body {
      background-color: #000;
      color: #fff;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    body > * {
      margin: 0;
      padding: 0;
    }
    /* ========== HERO SECTION ========== */
    .hero {
      background: url('https://emerald-above-tick-265.mypinata.cloud/ipfs/bafybeiabnekmlc67nxf6jboa6ndu7n6k4ci7qfobkcinzu3pmtwe54ovmi') center center no-repeat;
      background-size: cover;
      padding: 80px 0;
      text-align: center;
    }
    .hero h1 {
      font-size: 3rem;
      font-weight: bold;
      margin: 0;
    }
    /* ========== SECTION WRAPPER ========== */
    .section-wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }
    /* ========== NFT GALLERY ========== */
    .nft-gallery-title {
      text-align: center;
      margin-bottom: 2rem;
    }
    /* Loading Spinner */
    #loadingSpinner {
      text-align: center;
      margin: 10px 0;
    }
    /* ========== NFT CARD STYLES ========== */
    .nft-card {
      background-color: #1f1f1f;
      color: #ccc;
      border-radius: 8px;
      border: 1px solid #333;
      position: relative;
      overflow: hidden;
      transition: transform 0.2s ease-in-out;
      cursor: pointer;
    }
    .nft-card:hover {
      transform: scale(1.01);
    }
    /* Force images to a 1:1 aspect ratio */
    .nft-card img {
      aspect-ratio: 1 / 1;
      object-fit: cover;
      transition: transform 0.2s ease-in-out;
      border-radius: 8px 8px 0 0;
    }
    .nft-card:hover img {
      transform: scale(1.05);
    }
    .nft-card .card-body {
      padding: 1rem;
    }
    .nft-card .card-title {
      color: #eee;
      margin-bottom: 0.5rem;
    }
    .nft-card .card-text {
      color: #ccc;
      margin-bottom: 0;
    }
    /* Styles for unowned NFTs */
    .nft-card.unowned {
      background-color: #ddd;
      color: #555;
      filter: grayscale(100%);
      border: 1px solid #bbb;
    }
    .nft-card.unowned .card-title,
    .nft-card.unowned .card-text {
      color: #555;
    }
    /* Details Button (for owned tokens) */
    .see-details-btn {
      position: absolute;
      bottom: 5px;
      right: 5px;
      display: none;
      background-color: #007bff;
      color: #fff;
      border: none;
      padding: 0.3rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      text-transform: uppercase;
      transition: background-color 0.2s ease-in-out;
    }
    .see-details-btn:hover {
      background-color: #0056b3;
    }
    .nft-card:hover .see-details-btn {
      display: block;
    }
    /* ========== HEADER AND FOOTER PLACEHOLDERS ========== */
    #menu-placeholder, #footer-placeholder {
      width: 100%;
      color: #fff;
    }
    header.text-center.mb-4 {
      margin-top: 2rem;
    }
    /* ========== MODAL STYLES ========== */
    .modal-content {
      background-color: #1c1c1c;
      color: #fff;
    }
    .modal-header, .modal-body {
      border: none;
    }
    .modal-header .btn-close {
      filter: invert(100%);
    }
    /* Marketplace Actions inside the modal */
    #marketplaceActions button {
      margin-right: 10px;
      margin-bottom: 10px;
    }
    #createListingForm label,
    #offerForm label {
      display: block;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <!-- Menu (Header) -->
  <div id="menu-placeholder"></div>
  <script>
    fetch('components/menu2.html')
      .then(r => r.text())
      .then(html => { document.getElementById('menu-placeholder').innerHTML = html; })
      .catch(err => console.error('Error loading menu2:', err));
  </script>
  <script src="components/menu2.js"></script>

  <!-- Hero Section -->
  <section class="hero">
    <div class="container">
      <h1 class="mt-3">BE REAL | BE ADRIAN</h1>
    </div>
  </section>

  <!-- Sección de botones debajo del Hero -->
  <section class="text-center my-4">
    <div class="container">
      <a href="/marketplace.html" class="btn btn-primary mx-2">Marketplace</a>
      <a href="/listings.html" class="btn btn-primary mx-2">Listings</a>
    </div>
  </section>

  <!-- MAIN CONTENT WRAPPER -->
  <div class="section-wrapper">
    <header class="text-center mb-4">
      <h2 id="tokenBalance" class="display-4">Balance: Loading...</h2>
      <p id="accountDisplay" class="mt-2"></p>
    </header>

    <!-- NFT Gallery Section -->
    <section>
      <div id="loadingSpinner" style="display:none;">
        <div class="spinner-border text-light" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
      </div>
      <div id="nftGallery" class="row"></div>
    </section>
  </div>

  <!-- Modal for showing NFT metadata and marketplace actions -->
  <div class="modal fade" id="metadataModal" tabindex="-1" aria-labelledby="metadataModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="metadataModalLabel"></h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="metadataContent">
          <!-- El contenido se inyecta dinámicamente mediante JS -->
        </div>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <div id="footer-placeholder"></div>
  <script>
    fetch('components/footer.html')
      .then(response => response.text())
      .then(html => { document.getElementById('footer-placeholder').innerHTML = html; })
      .catch(error => { console.error('Error loading footer:', error); });
  </script>

  <!-- Scripts and logic -->
  <script>
    // Cache duration en milisegundos (2 días)
    const CACHE_DURATION = 2 * 24 * 60 * 60 * 1000;

    // Función para obtener metadata utilizando localStorage como caché
    async function getMetadata(tokenURI) {
      const cached = localStorage.getItem(tokenURI);
      if (cached) {
        try {
          const parsed = JSON.parse(cached);
          if (Date.now() - parsed.timestamp < CACHE_DURATION) {
            return parsed.data;
          }
        } catch (e) {
          console.error("Error parsing cache for", tokenURI, e);
        }
      }
      try {
        const response = await fetch(tokenURI);
        const metadata = await response.json();
        const toStore = { timestamp: Date.now(), data: metadata };
        localStorage.setItem(tokenURI, JSON.stringify(toStore));
        return metadata;
      } catch (error) {
        console.error("Error fetching metadata from", tokenURI, error);
        return {};
      }
    }

    // Función para comprimir la dirección del wallet (ej: 0x1234...abcd)
    function compressAddress(address) {
      return address.substring(0, 6) + "..." + address.substring(address.length - 4);
    }

    // Variables de conexión y contratos
    let provider, signer, userAccount;
    const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const nftCollectionAddress = "0xa92a8F5A47efC77da796dfD0827D07872E7D0429";
    const collectionAddress = nftCollectionAddress; // Para uso en marketplace

    // ABI para token (ERC20)
    const tokenABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)"
    ];

    // ABI para NFT (parcial)
    const nftABI = [
      "function balanceOf(address account, uint256 id) view returns (uint256)",
      "function uri(uint256 id) view returns (string)",
      "function nextEventId() view returns (uint256)"
    ];

    // Variables y ABI para el Marketplace
    const marketplaceAddress = "0x424a2456cc04724508f2bdb11b572d79da1fa244";
    const marketplaceAbi = [
      "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration) external",
      "function cancelListing(uint256 listingId) external",
      "function buyListing(uint256 listingId) external",
      "function listingIdCounter() view returns (uint256)",
      "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
      "event ListingCreated(uint256 indexed listingId, address indexed seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)"
    ];
    // ABI mínimo para ERC1155 (para aprobaciones)
    const erc1155Abi = [
      "function setApprovalForAll(address operator, bool approved) external",
      "function isApprovedForAll(address account, address operator) external view returns (bool)"
    ];

    // ABI para ADRIANoffers (contrato de ofertas)
    const offersContractAddress = "0xD982506aF474aAc90008968548E9FC7686a38ede";
    const offersContractAbi = [
      "function makeOffer(uint256 tokenId, uint256 quantity, uint256 offerAmount) external",
      "function offerCounter() view returns (uint256)",
      "function offers(uint256) view returns (uint256 id, address buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount, bool exists)",
      "function acceptOffer(uint256 offerId) external"
    ];

    let tokenContract, nftContract, marketplaceContract, offersContract;

    //
    // FORMATEADORES
    //
    function formatBalance(balance) {
      const num = parseFloat(balance);
      if (num >= 1e6) return (num / 1e6).toFixed(1).replace(/\.0$/, "") + "M";
      if (num >= 1e3) return (num / 1e3).toFixed(1).replace(/\.0$/, "") + "K";
      return num.toString();
    }
    function formatWithCommasAndDecimals(amount) {
      const numeric = Number(amount);
      return numeric.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    // Flujo para el comprador: primero debe hacer approve y luego crear la oferta
    async function approveOfferTokens(tokenId) {
      const offerAmount = document.getElementById("offerAmount").value;
      const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
      // Calculamos la comisión del 1%
      const commissionWei = offerAmountWei.div(100);
      const totalApprovalWei = offerAmountWei.add(commissionWei);
      try {
        const allowance = await tokenContract.allowance(userAccount, offersContractAddress);
        if (allowance.lt(totalApprovalWei)) {
          const txApprove = await tokenContract.approve(offersContractAddress, totalApprovalWei);
          await txApprove.wait();
          alert("Approved " + ethers.utils.formatUnits(totalApprovalWei, 18) + " ADRIAN (offer + 1% commission).");
        } else {
          alert("Sufficient tokens already approved.");
        }
      } catch (error) {
        console.error("Error during approval:", error);
        alert("Error during approval: " + error.message);
      }
    }

    async function makeOfferForToken(tokenId) {
      const quantity = document.getElementById("offerQuantity").value;
      const offerAmount = document.getElementById("offerAmount").value;
      const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
      try {
        const tx = await offersContract.makeOffer(tokenId, quantity, offerAmountWei);
        await tx.wait();
        alert("Offer created successfully!");
        document.getElementById("offerForm").style.display = "none";
        loadOffersForToken(tokenId);
      } catch (error) {
        console.error("Error creating offer:", error);
        alert("Error creating offer: " + error.message);
      }
    }

    // La función acceptOffer es llamada por el vendedor (propietario del NFT)
    async function acceptOffer(offerId, tokenId) {
      try {
        // Conecta el contrato NFT con el signer para aprobar transferencias
        const nftContractForApproval = new ethers.Contract(nftCollectionAddress, erc1155Abi, signer);
        const approved = await nftContractForApproval.isApprovedForAll(userAccount, offersContractAddress);
        if (!approved) {
          const txApprove = await nftContractForApproval.setApprovalForAll(offersContractAddress, true);
          await txApprove.wait();
          alert("NFT Collection approved for offer acceptance.");
        }
        const offer = await offersContract.offers(offerId);
        const buyerAllowance = await tokenContract.allowance(offer.buyer, offersContractAddress);
        console.log("Offer amount:", offer.offerAmount.toString());
        console.log("Buyer allowance:", buyerAllowance.toString());
        if (buyerAllowance.lt(offer.offerAmount)) {
          alert("Buyer has not approved enough tokens. Please ask the buyer to approve the full amount (offer + 1% commission).");
          return;
        }
        const sellerNFTBalance = await nftContract.balanceOf(userAccount, tokenId);
        if (sellerNFTBalance.lt(offer.quantity)) {
          alert("You do not own enough of this NFT.");
          return;
        }
        const tx = await offersContract.acceptOffer(offerId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Offer accepted successfully!");
        loadOffersForToken(tokenId);
        loadListingsForToken(tokenId);
      } catch (error) {
        console.error("Error accepting offer:", error);
        alert("Error accepting offer: " + error.message);
      }
    }

    function openCreateListingForm(tokenId) {
      const formDiv = document.getElementById("createListingForm");
      formDiv.style.display = "block";
      formDiv.innerHTML = `
          <h5>Create Listing:</h5>
          <label>Quantity:
            <input type="number" id="listingQuantity" value="1" min="1">
          </label>
          <label>Price per NFT in $ADRIAN:
            <input type="text" id="listingPrice" value="10">
          </label>
          <label>Duration:
            <select id="listingDuration">
              <option value="3600">1 hour</option>
              <option value="86400">1 day</option>
              <option value="604800">7 days</option>
              <option value="2592000">30 days</option>
              <option value="15552000">6 months</option>
            </select>
          </label>
          <button class="btn btn-primary mt-2" onclick="createListingForToken(${tokenId})">Approve AdrianGallery & Create Listing</button>
      `;
    }

    function openMakeOfferForm(tokenId) {
      const formDiv = document.getElementById("offerForm");
      formDiv.style.display = "block";
      formDiv.innerHTML = `
          <h5>Make an Offer:</h5>
          <label>Quantity:
            <input type="number" id="offerQuantity" value="1" min="1">
          </label>
          <label>Offer Amount (in ADRIAN tokens):
            <input type="text" id="offerAmount" value="10000">
          </label>
          <!-- Botón para hacer approve primero -->
          <button class="btn btn-warning mt-2" onclick="approveOfferTokens(${tokenId})">Approve Tokens</button>
          <!-- Botón para luego crear la oferta -->
          <button class="btn btn-primary mt-2" onclick="makeOfferForToken(${tokenId})">Submit Offer</button>
      `;
    }

    async function createListingForToken(tokenId) {
      if (!marketplaceContract) {
        alert("Marketplace not initialized.");
        return;
      }
      const quantity = document.getElementById("listingQuantity").value;
      const pricePerNFT = document.getElementById("listingPrice").value;
      const durationSeconds = document.getElementById("listingDuration").value;
      const totalPrice = ethers.utils.parseUnits(pricePerNFT, 18).mul(quantity);
      const nftContractForApproval = new ethers.Contract(collectionAddress, erc1155Abi, signer);
      try {
        const approved = await nftContractForApproval.isApprovedForAll(userAccount, marketplaceAddress);
        if (!approved) {
          const txApprove = await nftContractForApproval.setApprovalForAll(marketplaceAddress, true);
          await txApprove.wait();
          alert("Collection approved for NFT transfers.");
        }
      } catch (error) {
        console.error("Error approving collection:", error);
        alert("Error approving collection: " + error.message);
        return;
      }
      try {
        const tx = await marketplaceContract.createListing(collectionAddress, tokenId, quantity, totalPrice, durationSeconds);
        const receipt = await tx.wait();
        let listingId;
        for (let event of receipt.events) {
          if (event.event === "ListingCreated") {
            listingId = event.args.listingId.toString();
            break;
          }
        }
        if (listingId) {
          alert("Listing created with ID: " + listingId);
        } else {
          alert("Listing created, but listing ID was not found.");
        }
      } catch (error) {
        console.error("Error creating listing:", error);
        alert("Error creating listing: " + error.message);
      }
    }

    async function loadListingsForToken(tokenId) {
      if (!marketplaceContract) {
        console.error("Marketplace not initialized.");
        return;
      }
      try {
        const counter = await marketplaceContract.listingIdCounter();
        const listingsDiv = document.getElementById("marketplaceListings");
        listingsDiv.innerHTML = "<p>Loading listings...</p>";
        let listingsFound = [];
        for (let i = 1; i <= counter.toNumber(); i++) {
          try {
            let listing = await marketplaceContract.listings(i);
            if (
              listing.seller !== ethers.constants.AddressZero &&
              listing.collection.toLowerCase() === collectionAddress.toLowerCase() &&
              listing.tokenId.toString() === tokenId.toString()
            ) {
              listingsFound.push(listing);
            }
          } catch (e) {
            console.error("Error fetching listing", i, e);
          }
        }
        if (listingsFound.length === 0) {
          listingsDiv.innerHTML = "<p>No listings for this token.</p>";
        } else {
          let listingsHtml = "<ul>";
          listingsFound.forEach(listing => {
            let pricePerNFT = ethers.utils.formatUnits(listing.price.div(listing.quantity), 18);
            listingsHtml += `<li>
                Price per NFT: ${formatWithCommasAndDecimals(pricePerNFT)} $ADRIAN | Quantity: ${listing.quantity.toString()}
                <button class="btn btn-sm btn-success" onclick="buyListingById(${listing.id.toString()})">Buy</button>
              </li>`;
          });
          listingsHtml += "</ul>";
          listingsDiv.innerHTML = listingsHtml;
        }
      } catch (error) {
        console.error("Error loading listings for token:", error);
        document.getElementById("marketplaceListings").innerHTML = "<p>Error loading listings.</p>";
      }
    }

    async function loadOffersForToken(tokenId) {
      if (!offersContract) {
        console.error("Offers contract not initialized.");
        return;
      }
      try {
        const counter = await offersContract.offerCounter();
        const offersDiv = document.getElementById("marketplaceOffers");
        offersDiv.innerHTML = "<p>Loading offers...</p>";
        let offersFound = [];
        for (let i = 1; i <= counter.toNumber(); i++) {
          try {
            let offer = await offersContract.offers(i);
            if (offer.exists && offer.tokenId.toString() === tokenId.toString()) {
              offersFound.push(offer);
            }
          } catch (e) {
            console.error("Error fetching offer", i, e);
          }
        }
        if (offersFound.length === 0) {
          offersDiv.innerHTML = "<p>No active offers for this token.</p>";
        } else {
          let offersHtml = "<h5>Active Offers:</h5><ul>";
          offersFound.forEach(offer => {
            let formattedOfferAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
            offersHtml += `<li>
                Buyer: ${compressAddress(offer.buyer)} | Offer: ${formatWithCommasAndDecimals(formattedOfferAmount)} $ADRIAN | Quantity: ${offer.quantity.toString()}
                <button class="btn btn-sm btn-success" onclick="acceptOffer(${offer.id.toString()}, ${tokenId})">Accept Offer</button>
              </li>`;
          });
          offersHtml += "</ul>";
          offersDiv.innerHTML = offersHtml;
        }
      } catch (error) {
        console.error("Error loading offers for token:", error);
        document.getElementById("marketplaceOffers").innerHTML = "<p>Error loading offers.</p>";
      }
    }

    async function buyListingById(listingId) {
      if (!marketplaceContract) {
        alert("Connect your wallet first.");
        return;
      }
      try {
        const listing = await marketplaceContract.listings(listingId);
        if (listing.seller === ethers.constants.AddressZero) {
          alert("Listing does not exist or has been cancelled.");
          return;
        }
        const requiredAmount = listing.price;
        const currentAllowance = await tokenContract.allowance(userAccount, marketplaceAddress);
        if (currentAllowance.lt(requiredAmount)) {
          const txApprove = await tokenContract.approve(marketplaceAddress, requiredAmount);
          await txApprove.wait();
          const approvedAmountStr = formatWithCommasAndDecimals(ethers.utils.formatUnits(requiredAmount, 18));
          alert("Approved " + approvedAmountStr + " ADRIAN for purchase.");
        }
        const tx = await marketplaceContract.buyListing(listingId);
        await tx.wait();
        alert("Listing purchased successfully.");
        loadListingsForToken(listing.tokenId);
      } catch (error) {
        console.error("Purchase error:", error);
        alert("Error buying listing: " + error.message);
      }
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="https://files.catbox.moe/ffvdjy.svg" type="image/svg+xml">
  <meta charset="UTF-8">
  <title>$ADRIAN Listings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Custom Styles -->
  <style>
    /* ========== GLOBAL STYLES ========== */
    body {
      background-color: #000;
      color: #fff;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    body > * {
      margin: 0;
      padding: 0;
    }
    /* ========== HERO SECTION ========== */
    .hero {
      background: url('https://emerald-above-tick-265.mypinata.cloud/ipfs/bafybeiabnekmlc67nxf6jboa6ndu7n6k4ci7qfobkcinzu3pmtwe54ovmi') center center no-repeat;
      background-size: cover;
      padding: 80px 0;
      text-align: center;
    }
    .hero h1 {
      font-size: 3rem;
      font-weight: bold;
      margin: 0;
    }
    /* ========== SECTION WRAPPER ========== */
    .section-wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }
    /* ========== MARKETPLACE CARD STYLES ========== */
    .marketplace-card {
      background-color: #1f1f1f;
      border: 1px solid #333;
      border-radius: 8px;
      overflow: hidden;
      transition: transform 0.2s ease-in-out;
      margin-bottom: 20px;
    }
    .marketplace-card:hover {
      transform: scale(1.01);
    }
    .card-row {
      display: flex;
      flex-wrap: nowrap;
    }
    .card-img-col, .card-info-col {
      flex: 1;
    }
    .card-img-col img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .card-info-col {
      padding: 1rem;
    }
    .card-title {
      color: #eee;
      margin-bottom: 0.5rem;
    }
    .card-text {
      color: #ccc;
      margin-bottom: 0.5rem;
    }
    .buy-button {
      background-color: #28a745;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
    }
    .buy-button:hover {
      background-color: #218838;
    }
    /* ========== HEADER AND FOOTER PLACEHOLDERS ========== */
    #menu-placeholder, #footer-placeholder {
      width: 100%;
      color: #fff;
    }
    header.text-center.mb-4 {
      margin-top: 2rem;
    }
    /* ========== MODAL STYLES (if needed) ========== */
    .modal-content {
      background-color: #1c1c1c;
      color: #fff;
    }
    .modal-header, .modal-body {
      border: none;
    }
    .modal-header .btn-close {
      filter: invert(100%);
    }
  </style>
</head>
<body>
  <!-- Menu (Header) -->
  <div id="menu-placeholder"></div>
  <script>
    fetch('components/menu2.html')
      .then(r => r.text())
      .then(html => { document.getElementById('menu-placeholder').innerHTML = html; })
      .catch(err => console.error('Error loading menu2:', err));
  </script>
  <script src="components/menu2.js"></script>

  <!-- Hero Section -->
  <section class="hero">
    <div class="container">
      <h1 class="mt-3">BE REAL | BE ADRIAN</h1>
    </div>
  </section>

  <!-- Sección de botones debajo del Hero -->
  <section class="text-center my-4">
    <div class="container">
      <a href="/marketplace.html" class="btn btn-primary mx-2">Marketplace</a>
      <a href="/listings.html" class="btn btn-primary mx-2">Listings</a>
    </div>
  </section>

  <!-- MAIN CONTENT WRAPPER -->
  <div class="section-wrapper">
    <header class="text-center mb-4">
      <h2 id="tokenBalance" class="display-4">Balance: Loading...</h2>
      <p id="accountDisplay" class="mt-2"></p>
    </header>

    <!-- Marketplace Listings Section -->
    <section>
      <h2 class="text-center mb-4">Marketplace Listings</h2>
      <div id="marketplaceListings" class="row"></div>
    </section>

    <!-- Offers Section -->
    <section>
      <h2 class="text-center mb-4">Offers</h2>
      <div class="container">
        <!-- Make Offer -->
        <h3>Make Offer</h3>
        <div class="mb-2">
          <label for="offerTokenSelector">Select NFT:</label>
          <select id="offerTokenSelector" class="form-select"></select>
        </div>
        <div class="mb-2">
          <label for="offerQuantity">Quantity:</label>
          <input type="number" id="offerQuantity" value="1" min="1" class="form-control" style="max-width:200px;">
        </div>
        <div class="mb-2">
          <label for="offerAmount">Offer Amount ($ADRIAN):</label>
          <input type="number" id="offerAmount" placeholder="1000.00" step="any" class="form-control" style="max-width:200px;">
        </div>
        <button id="makeOfferButton" class="btn btn-primary my-2">Make Offer</button>
        <hr>
        <!-- All Offers -->
        <h3>All Offers</h3>
        <button id="loadAllOffersButton" class="btn btn-secondary mb-2">Load All Offers</button>
        <div id="offersList"></div>
      </div>
    </section>

    <!-- Sales Section -->
    <section>
      <h2 class="text-center mb-4">Sales</h2>
      <div id="sales" class="container"></div>
    </section>
  </div>

  <!-- Footer -->
  <div id="footer-placeholder"></div>
  <script>
    fetch('components/footer.html')
      .then(response => response.text())
      .then(html => { document.getElementById('footer-placeholder').innerHTML = html; })
      .catch(error => { console.error('Error loading footer:', error); });
  </script>

  <!-- Scripts and Logic -->
  <script>
    /*****************
     * Helper Functions
     *****************/
    const CACHE_DURATION = 2 * 24 * 60 * 60 * 1000; // 2 days

    async function getMetadata(tokenURI) {
      const cached = localStorage.getItem(tokenURI);
      if (cached) {
        try {
          const parsed = JSON.parse(cached);
          if (Date.now() - parsed.timestamp < CACHE_DURATION) {
            return parsed.data;
          }
        } catch (e) {
          console.error("Error parsing cache for", tokenURI, e);
        }
      }
      try {
        if (tokenURI.startsWith("ipfs://")) {
          tokenURI = tokenURI.replace("ipfs://", "https://ipfs.io/ipfs/");
        }
        const response = await fetch(tokenURI);
        const metadata = await response.json();
        localStorage.setItem(tokenURI, JSON.stringify({ timestamp: Date.now(), data: metadata }));
        return metadata;
      } catch (error) {
        console.error("Error fetching metadata from", tokenURI, error);
        return {};
      }
    }

    function formatBalance(balance) {
      const num = parseFloat(balance);
      if (num >= 1e6) return (num / 1e6).toFixed(1).replace(/\.0$/, "") + "M";
      if (num >= 1e3) return (num / 1e3).toFixed(1).replace(/\.0$/, "") + "K";
      return num.toString();
    }
    function formatWithCommasAndDecimals(amount) {
      const numeric = Number(amount);
      return numeric.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    function truncateAddress(address) {
      return address.substring(0, 6) + "..." + address.substring(address.length - 3);
    }
    // Helpers for conversion (asumiendo 18 decimales)
    function toWei(amount) {
      return ethers.utils.parseUnits(amount.toString(), 18);
    }
    function fromWei(amount) {
      return parseFloat(ethers.utils.formatUnits(amount, 18)).toFixed(2);
    }

    /*****************
     * Global Variables and Contract Config
     *****************/
    let provider, signer, userAccount;
    const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea"; // $ADRIAN token
    const nftCollectionAddress = "0xa92a8F5A47efC77da796dfD0827D07872E7D0429"; // NFT collection contract
    const marketplaceAddress = "0x424a2456cc04724508f2bdb11b572d79da1fa244"; // Marketplace contract

    const tokenABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)"
    ];
    const marketplaceAbi = [
      "function listingIdCounter() view returns (uint256)",
      "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
      "function buyListing(uint256 listingId) external",
      "event ListingCreated(uint256 indexed listingId, address indexed seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
      "event OfferMade(uint256 indexed listingId, address indexed buyer, uint256 offerAmount)",
      "event OfferAccepted(uint256 indexed listingId, address indexed buyer)",
      "event ListingPurchased(uint256 indexed listingId, address indexed buyer)"
    ];
    const erc1155Abi = [
      "function uri(uint256 tokenId) view returns (string)",
      "function balanceOf(address account, uint256 id) external view returns (uint256)"
    ];

    // --- Variables para ADRIANoffers ---
    const ADRIANoffersAddress = "0xd982506af474aac90008968548e9fc7686a38ede";
    const ADRIANoffersAbi = [
      "function makeOffer(uint256 tokenId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawOffer(uint256 offerId) external",
      "function acceptOffer(uint256 offerId) external",
      "function offers(uint256) external view returns (uint256 id, address buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount, bool exists)",
      "function offerCounter() external view returns (uint256)",
      "event OfferCreated(uint256 indexed offerId, address indexed buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount)",
      "event OfferWithdrawn(uint256 indexed offerId, address indexed buyer)",
      "event OfferAccepted(uint256 indexed offerId, address indexed buyer, address indexed seller)"
    ];

    let tokenContract, marketplaceContract;
    let offersContract;      // Contrato ADRIANoffers
    let nftOffersContract;   // Contrato NFT para offers (se usa la misma dirección que nftCollectionAddress)

    /*****************
     * Wallet Connection from Menu
     *****************/
    window.onMenuWalletConnected = async function() {
      provider = window.menuProvider;
      signer = window.menuSigner;
      userAccount = window.menuUserAccount;
      tokenContract = new ethers.Contract(tokenAddress, tokenABI, signer);
      marketplaceContract = new ethers.Contract(marketplaceAddress, marketplaceAbi, signer);
      // Instanciar contratos de offers y NFT para offers
      offersContract = new ethers.Contract(ADRIANoffersAddress, ADRIANoffersAbi, signer);
      nftOffersContract = new ethers.Contract(nftCollectionAddress, erc1155Abi, provider);

      updateTokenBalance();
      document.getElementById("accountDisplay").innerText = "Wallet: " + truncateAddress(userAccount);
      loadMarketplaceListings();
      loadSales();
      // Funciones de ADRIANoffers
      loadNFTDropdown();
      loadAllOffers();
    };

    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balanceInt = balanceRaw.div(ethers.constants.WeiPerEther).toString();
        document.getElementById("tokenBalance").innerText = `Balance: ${formatBalance(balanceInt)} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }

    /*****************
     * Marketplace Listings
     *****************/
    async function loadMarketplaceListings() {
      const listingsDiv = document.getElementById("marketplaceListings");
      listingsDiv.innerHTML = "Loading listings...";
      try {
        const counter = await marketplaceContract.listingIdCounter();
        const currentBlock = await provider.getBlock("latest");
        const currentTime = currentBlock.timestamp;
        listingsDiv.innerHTML = "";
        for (let i = 1; i <= counter.toNumber(); i++) {
          try {
            const listing = await marketplaceContract.listings(i);
            if (listing.seller !== ethers.constants.AddressZero && currentTime <= listing.expirationTime) {
              const collectionContract = new ethers.Contract(listing.collection, erc1155Abi, provider);
              let tokenURI = await collectionContract.uri(listing.tokenId);
              const metadata = await getMetadata(tokenURI);
              const image = metadata.image 
                ? (metadata.image.startsWith("ipfs://") 
                    ? metadata.image.replace("ipfs://", "https://ipfs.io/ipfs/") 
                    : metadata.image)
                : "https://via.placeholder.com/300?text=No+Image";
              const tokenName = metadata.name || "Unnamed Token";
              const pricePerNFT = listing.price.div(listing.quantity);
              const formattedPrice = formatWithCommasAndDecimals(ethers.utils.formatUnits(pricePerNFT, 18));
              
              const colDiv = document.createElement("div");
              colDiv.className = "col-12 col-md-6 mb-4";
              colDiv.innerHTML = `
                <div class="marketplace-card">
                  <div class="row card-row">
                    <div class="col-6 card-img-col">
                      <img src="${image}" alt="${tokenName}">
                    </div>
                    <div class="col-6 card-info-col">
                      <h5 class="card-title">${tokenName}</h5>
                      <p class="card-text">Price: ${formattedPrice} $ADRIAN</p>
                      <p class="card-text">Quantity: ${listing.quantity.toString()}</p>
                      <p class="card-text">Seller: ${truncateAddress(listing.seller)}</p>
                      <button class="buy-button" onclick="buyListing(${listing.id.toString()})">Buy Now</button>
                    </div>
                  </div>
                </div>
              `;
              listingsDiv.appendChild(colDiv);
            }
          } catch (err) {
            console.error("Error loading listing", i, err);
          }
        }
      } catch (error) {
        console.error("Error fetching listings:", error);
        listingsDiv.innerHTML = "Error loading listings.";
      }
    }

    /*****************
     * Buy Listing with Approval
     *****************/
    async function buyListing(listingId) {
      try {
        const listing = await marketplaceContract.listings(listingId);
        if (listing.seller === ethers.constants.AddressZero) {
          alert("Listing does not exist or has been cancelled.");
          return;
        }
        const requiredAmount = listing.price;
        const currentAllowance = await tokenContract.allowance(userAccount, marketplaceAddress);
        if (currentAllowance.lt(requiredAmount)) {
          const txApprove = await tokenContract.approve(marketplaceAddress, requiredAmount);
          await txApprove.wait();
          const approvedAmountStr = formatWithCommasAndDecimals(ethers.utils.formatUnits(requiredAmount, 18));
          alert("Approved " + approvedAmountStr + " ADRIAN for purchase.");
        }
        const tx = await marketplaceContract.buyListing(listingId);
        await tx.wait();
        alert("Listing purchased successfully.");
        loadMarketplaceListings();
      } catch (error) {
        console.error("Error purchasing listing:", error);
        alert("Error buying listing: " + error.message);
      }
    }

    /*****************
     * Sales Section
     * Ordena las ventas de forma descendente (última venta primero)
     *****************/
    async function loadSales() {
      const salesDiv = document.getElementById("sales");
      salesDiv.innerHTML = "Loading sales...";
      let purchasedEvents = [];
      let acceptedEvents = [];
      const currentBlock = await provider.getBlockNumber();
      const fromBlock = window.innerWidth > 768 ? currentBlock - 100000 : 0;
      try {
        const purchasedFilter = marketplaceContract.filters.ListingPurchased();
        purchasedEvents = await marketplaceContract.queryFilter(purchasedFilter, fromBlock, currentBlock);
      } catch (error) {
        console.warn("No logs returned for purchased events; treating as empty.", error);
        purchasedEvents = [];
      }
      try {
        const acceptedFilter = marketplaceContract.filters.OfferAccepted();
        acceptedEvents = await marketplaceContract.queryFilter(acceptedFilter, fromBlock, currentBlock);
      } catch (error) {
        console.warn("No logs returned for accepted events; treating as empty.", error);
        acceptedEvents = [];
      }
      const saleEvents = [...purchasedEvents, ...acceptedEvents].sort((a, b) => b.blockNumber - a.blockNumber);
      salesDiv.innerHTML = "";
      for (const event of saleEvents) {
        const listingId = event.args.listingId.toString();
        let createdEvent;
        try {
          const createdFilter = marketplaceContract.filters.ListingCreated(listingId);
          const createdEvents = await marketplaceContract.queryFilter(createdFilter);
          if (createdEvents.length > 0) {
            createdEvent = createdEvents[0];
          }
        } catch (err) {
          console.error("Error fetching ListingCreated event for listing", listingId, err);
        }
        if (createdEvent) {
          const collectionContract = new ethers.Contract(createdEvent.args.collection, erc1155Abi, provider);
          let tokenURI = await collectionContract.uri(createdEvent.args.tokenId);
          const metadata = await getMetadata(tokenURI);
          const tokenName = metadata.name || "Unnamed Token";
          const sellerTruncated = truncateAddress(createdEvent.args.seller);
          const totalPrice = createdEvent.args.price;
          const formattedPrice = formatWithCommasAndDecimals(ethers.utils.formatUnits(totalPrice, 18));
          const saleDiv = document.createElement("div");
          saleDiv.className = "mb-2";
          saleDiv.innerHTML = `<p>Token: ${tokenName} | Seller: ${sellerTruncated} | Price: ${formattedPrice} $ADRIAN</p>`;
          salesDiv.appendChild(saleDiv);
        }
      }
    }

    /*****************
     * ADRIANoffers Functions
     *****************/

    // Carga el dropdown de NFTs (se asume tokenIDs 1 a 10)
    async function loadNFTDropdown() {
      const dropdown = document.getElementById("offerTokenSelector");
      dropdown.innerHTML = "";
      for (let tokenId = 1; tokenId <= 10; tokenId++) {
        try {
          let tokenName = "Token #" + tokenId;
          let tokenUri = await nftOffersContract.uri(tokenId);
          tokenUri = tokenUri.replace("{id}", tokenId.toString());
          const response = await fetch(tokenUri);
          const metadata = await response.json();
          if (metadata.name) {
            tokenName = metadata.name;
          }
          const option = document.createElement("option");
          option.value = tokenId;
          option.text = tokenName;
          dropdown.appendChild(option);
        } catch (err) {
          console.error("Error loading token", tokenId, err);
        }
      }
    }

    // Hace una oferta llamando a makeOffer en ADRIANoffers
    document.getElementById("makeOfferButton").addEventListener("click", async () => {
      try {
        if (!offersContract) {
          alert("Please connect your wallet first.");
          return;
        }
        const tokenId = document.getElementById("offerTokenSelector").value;
        const quantity = document.getElementById("offerQuantity").value;
        const offerInput = document.getElementById("offerAmount").value;
        if (!offerInput || isNaN(offerInput)) {
          alert("Enter a valid offer amount.");
          return;
        }
        const offerAmount = toWei(offerInput);
        const tx = await offersContract.makeOffer(tokenId, quantity, offerAmount);
        await tx.wait();
        alert("Offer made successfully!");
        loadAllOffers();
      } catch (err) {
        console.error(err);
        alert("Error making offer: " + err.message);
      }
    });

    // Botón para recargar todas las ofertas
    document.getElementById("loadAllOffersButton").addEventListener("click", loadAllOffers);

    // Carga todas las ofertas activas iterando desde 1 hasta offerCounter
    async function loadAllOffers() {
      if (!offersContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const offersListDiv = document.getElementById("offersList");
      offersListDiv.innerHTML = "Loading offers...";
      try {
        const counter = await offersContract.offerCounter();
        let html = `<table class="table table-dark table-striped">
                      <tr>
                        <th>Offer ID</th>
                        <th>Token</th>
                        <th>Quantity</th>
                        <th>Offer Amount ($ADRIAN)</th>
                        <th>Buyer</th>
                        <th>Actions</th>
                      </tr>`;
        for (let i = 1; i <= counter; i++) {
          try {
            const offer = await offersContract.offers(i);
            if (offer.exists) {
              let tokenName = "Token #" + offer.tokenId;
              try {
                let tokenUri = await nftOffersContract.uri(offer.tokenId);
                tokenUri = tokenUri.replace("{id}", offer.tokenId.toString());
                const response = await fetch(tokenUri);
                const metadata = await response.json();
                if (metadata.name) {
                  tokenName = metadata.name;
                }
              } catch (err) {
                console.log("Error fetching metadata for token", offer.tokenId, err);
              }
              let actions = "";
              // Si el usuario conectado es el comprador, muestra "Withdraw Offer"
              if (offer.buyer.toLowerCase() === userAccount.toLowerCase()) {
                actions += `<button class="btn btn-sm btn-warning" onclick="withdrawOffer(${offer.id})">Withdraw Offer</button>`;
              }
              // Si el usuario conectado posee suficientes NFT, muestra "Accept Offer"
              const sellerBalance = await nftOffersContract.balanceOf(userAccount, offer.tokenId);
              if (sellerBalance.gte(offer.quantity)) {
                actions += `<button class="btn btn-sm btn-success" onclick="acceptOffer(${offer.id})">Accept Offer</button>`;
              }
              html += `<tr>
                          <td>${offer.id}</td>
                          <td>${tokenName} (ID: ${offer.tokenId})</td>
                          <td>${offer.quantity}</td>
                          <td>${fromWei(offer.offerAmount)}</td>
                          <td>${offer.buyer}</td>
                          <td>${actions}</td>
                       </tr>`;
            }
          } catch (err) {
            console.error("Error fetching offer", i, err);
          }
        }
        html += "</table>";
        offersListDiv.innerHTML = html;
      } catch (err) {
        console.error(err);
        offersListDiv.innerHTML = "Error loading offers: " + err.message;
      }
    }

    // Función para aceptar una oferta (primero aprueba el gasto del token ADRIAN)
    async function acceptOffer(offerId) {
      try {
        if (!offersContract) {
          alert("Please connect your wallet first.");
          return;
        }
        // Obtener datos de la oferta para saber el valor a aprobar
        const offer = await offersContract.offers(offerId);
        if (!offer.exists) {
          alert("Offer does not exist.");
          return;
        }
        const offerAmount = offer.offerAmount;
        // Verificar si ya se ha aprobado el gasto de ADRIAN token para el contrato de offers
        const currentAllowance = await tokenContract.allowance(userAccount, ADRIANoffersAddress);
        if (currentAllowance.lt(offerAmount)) {
          const txApprove = await tokenContract.approve(ADRIANoffersAddress, offerAmount);
          await txApprove.wait();
          alert("Approved " + formatWithCommasAndDecimals(ethers.utils.formatUnits(offerAmount, 18)) + " ADRIAN for offer acceptance.");
        }
        const tx = await offersContract.acceptOffer(offerId);
        await tx.wait();
        alert("Offer accepted successfully!");
        loadAllOffers();
      } catch (err) {
        console.error(err);
        alert("Error accepting offer: " + err.message);
      }
    }

    // Función para retirar una oferta
    async function withdrawOffer(offerId) {
      try {
        if (!offersContract) {
          alert("Please connect your wallet first.");
          return;
        }
        const tx = await offersContract.withdrawOffer(offerId);
        await tx.wait();
        alert("Offer withdrawn successfully!");
        loadAllOffers();
      } catch (err) {
        console.error(err);
        alert("Error withdrawing offer: " + err.message);
      }
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

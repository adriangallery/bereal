<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NFT Marketplace v2 Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .section { margin-bottom: 20px; }
    label { display: block; margin: 5px 0; }
    input, select { padding: 5px; width: 300px; }
    button { padding: 7px 15px; margin-top: 10px; }
    ul { list-style: none; padding: 0; }
    li { border: 1px solid #ddd; margin-bottom: 5px; padding: 5px; }
  </style>
</head>
<body>
  <h1>NFT Marketplace v2 Demo</h1>

  <!-- Wallet Connection Section -->
  <div class="section">
    <button id="connectButton">Connect Wallet</button>
    <p id="walletAddress">Wallet not connected</p>
  </div>

  <!-- Create Listing Section -->
  <div class="section">
    <h2>Create Listing</h2>
    <!-- Collection is hardcoded -->
    <p>Collection: <strong>AdrianGallery (0xa92a8F5A47efC77da796dfD0827D07872E7D0429)</strong></p>
    <label>
      Token ID:
      <input id="tokenIdInput" type="number" value="7">
    </label>
    <label>
      Quantity:
      <input id="quantityInput" type="number" value="1">
    </label>
    <label>
      Price per NFT (ADRIAN):
      <input id="priceInput" type="text" value="10">
    </label>
    <label>
      Duration:
      <select id="durationSelect">
        <option value="3600">1 hour</option>
        <option value="86400">1 day</option>
        <option value="604800">7 days</option>
        <option value="2592000">30 days</option>
        <option value="15552000">6 months</option>
      </select>
    </label>
    <button id="createListingButton">Approve AdrianGallery & Create Listing</button>
  </div>

  <!-- Active Listings Section -->
  <div class="section">
    <h2>Active Listings</h2>
    <button id="refreshListingsButton">Refresh Listings</button>
    <ul id="listingsDisplay"></ul>
  </div>

  <!-- Listing Actions Section -->
  <div class="section">
    <h2>Listing Actions</h2>
    <label>
      Listing ID:
      <input id="listingIdInput" type="number">
    </label>
    <button id="buyListingButton">Buy Listing (entire listing)</button>
    <button id="cancelListingButton">Cancel Listing</button>
  </div>

  <script>
    // Hardcoded contract addresses:
    const marketplaceAddress = "0x424a2456cc04724508f2bdb11b572d79da1fa244";
    const collectionAddress = "0xa92a8F5A47efC77da796dfD0827D07872E7D0429"; // AdrianGallery
    // Hardcoded ADRIAN token (18 decimals)
    const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";

    // ABIs for ERC1155 (for approvals) and marketplace
    const erc1155Abi = [
      "function setApprovalForAll(address operator, bool approved) external",
      "function isApprovedForAll(address account, address operator) external view returns (bool)"
    ];

    const marketplaceAbi = [
      "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration) external",
      "function cancelListing(uint256 listingId) external",
      "function buyListing(uint256 listingId) external",
      "function listingIdCounter() view returns (uint256)",
      "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
      "event ListingCreated(uint256 indexed listingId, address indexed seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
      "event ListingCancelled(uint256 indexed listingId)",
      "event ListingPurchased(uint256 indexed listingId, address indexed buyer)"
    ];

    // ABI for ERC20 (for token approvals)
    const erc20Abi = [
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 amount) returns (bool)"
    ];

    let provider, signer, walletAddress;
    let marketplaceContract, tokenContract;

    async function connectWallet() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        walletAddress = await signer.getAddress();
        document.getElementById("walletAddress").innerText = "Wallet: " + walletAddress;
        marketplaceContract = new ethers.Contract(marketplaceAddress, marketplaceAbi, signer);
        tokenContract = new ethers.Contract(tokenAddress, erc20Abi, signer);
      } else {
        alert("Please install MetaMask.");
      }
    }
    document.getElementById("connectButton").addEventListener("click", connectWallet);

    async function approveAndCreateListing() {
      if (!marketplaceContract) {
        alert("Connect your wallet first.");
        return;
      }
      const tokenId = document.getElementById("tokenIdInput").value;
      const quantity = document.getElementById("quantityInput").value;
      const pricePerNFT = document.getElementById("priceInput").value;
      const durationSeconds = document.getElementById("durationSelect").value;
      // Calculate total price = price per NFT * quantity (both as string numbers)
      const totalPrice = ethers.utils.parseUnits(pricePerNFT, 18).mul(quantity);

      // Approve the AdrianGallery collection for NFT transfers
      const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, signer);
      try {
        const approved = await nftContract.isApprovedForAll(walletAddress, marketplaceAddress);
        if (!approved) {
          const txApprove = await nftContract.setApprovalForAll(marketplaceAddress, true);
          await txApprove.wait();
          alert("AdrianGallery collection approved for NFT transfers.");
        }
      } catch (error) {
        console.error("Approval error:", error);
        alert("Error approving AdrianGallery: " + error.message);
        return;
      }
      
      // Create the listing with totalPrice = quantity * (price per NFT)
      try {
        const tx = await marketplaceContract.createListing(collectionAddress, tokenId, quantity, totalPrice, durationSeconds);
        const receipt = await tx.wait();
        // Search for the ListingCreated event
        const event = receipt.events.find(e => e.event === "ListingCreated");
        if (event) {
          alert("Listing created with ID: " + event.args.listingId.toString());
        } else {
          alert("Listing created, but listing ID was not found.");
        }
      } catch (error) {
        console.error("Error creating listing:", error);
        alert("Error creating listing: " + error.message);
      }
    }
    document.getElementById("createListingButton").addEventListener("click", approveAndCreateListing);

    // Function to refresh active listings (by iterating from 1 to listingIdCounter)
    async function refreshListings() {
      if (!marketplaceContract) {
        alert("Connect your wallet first.");
        return;
      }
      try {
        const counter = await marketplaceContract.listingIdCounter();
        const display = document.getElementById("listingsDisplay");
        display.innerHTML = "";
        for (let i = 1; i <= counter.toNumber(); i++) {
          try {
            const listing = await marketplaceContract.listings(i);
            // If seller is address(0), the listing doesn't exist (deleted)
            if (listing.seller !== ethers.constants.AddressZero) {
              // Calculate price per NFT = totalPrice / quantity
              const pricePerNFT = ethers.utils.formatUnits(listing.price.div(listing.quantity), 18);
              const li = document.createElement("li");
              li.innerText = "ID: " + listing.id.toString() +
                             " | Token ID: " + listing.tokenId.toString() +
                             " | Price per NFT: " + pricePerNFT + " ADRIAN" +
                             " | Quantity: " + listing.quantity.toString();
              display.appendChild(li);
            }
          } catch (err) {
            console.error("Error fetching listing " + i, err);
          }
        }
      } catch (error) {
        console.error("Error fetching listings:", error);
        alert("Error fetching listings: " + error.message);
      }
    }
    document.getElementById("refreshListingsButton").addEventListener("click", refreshListings);

    async function buyListing() {
      if (!marketplaceContract) {
        alert("Connect your wallet first.");
        return;
      }
      const listingId = document.getElementById("listingIdInput").value;
      if (!listingId) {
        alert("Enter a listing ID.");
        return;
      }
      // Note: The contract v1 buys the entire listing.
      // Get listing details to confirm it exists.
      let listing;
      try {
        listing = await marketplaceContract.listings(listingId);
        if (listing.seller === ethers.constants.AddressZero) {
          alert("Listing does not exist or has been cancelled.");
          return;
        }
      } catch (error) {
        console.error("Error reading listing:", error);
        alert("Error reading listing: " + error.message);
        return;
      }
      // Approve ADRIAN tokens if needed
      try {
        const requiredAmount = listing.price; // total price for the listing
        const currentAllowance = await tokenContract.allowance(walletAddress, marketplaceAddress);
        if (currentAllowance.lt(requiredAmount)) {
          const txApprove = await tokenContract.approve(marketplaceAddress, requiredAmount);
          await txApprove.wait();
          alert("Approved " + ethers.utils.formatUnits(requiredAmount, 18) + " ADRIAN for purchase.");
        }
      } catch (error) {
        console.error("Token approval error:", error);
        alert("Error approving ADRIAN tokens: " + error.message);
        return;
      }
      
      try {
        const tx = await marketplaceContract.buyListing(listingId);
        await tx.wait();
        alert("Listing purchased successfully.");
      } catch (error) {
        console.error("Purchase error:", error);
        alert("Error buying listing: " + error.message);
      }
    }
    document.getElementById("buyListingButton").addEventListener("click", buyListing);

    async function cancelListing() {
      if (!marketplaceContract) {
        alert("Connect your wallet first.");
        return;
      }
      const listingId = document.getElementById("listingIdInput").value;
      if (!listingId) {
        alert("Enter a listing ID to cancel.");
        return;
      }
      try {
        const tx = await marketplaceContract.cancelListing(listingId);
        await tx.wait();
        alert("Listing cancelled successfully.");
      } catch (error) {
        console.error("Cancel error:", error);
        alert("Error cancelling listing: " + error.message);
      }
    }
    document.getElementById("cancelListingButton").addEventListener("click", cancelListing);
  </script>
</body>
</html>

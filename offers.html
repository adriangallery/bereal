<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>NFT Marketplace Offers</title>
    <!-- Favicon básico para evitar errores 404 -->
    <link rel="icon" href="data:,">
    <!-- Cargar ethers.js desde CDN confiable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      h1, h2 { color: #333; }
      input, select, button { margin: 5px 0; padding: 5px; }
      table { border-collapse: collapse; margin-top: 10px; }
      table, th, td { border: 1px solid #ccc; padding: 8px; }
    </style>
  </head>
  <body>
    <h1>NFT Marketplace Offers</h1>
    <button id="connectButton">Connect Wallet</button>
    <p id="walletStatus">Wallet not connected</p>
    <hr />

    <!-- Sección: Hacer Oferta -->
    <h2>Make Offer</h2>
    <div>
      <label for="offerListingSelector">Select Listing:</label>
      <!-- Se cargará automáticamente con los listados activos de Adriangallery -->
      <select id="offerListingSelector">
        <!-- Opciones llenadas dinámicamente -->
      </select>
    </div>
    <div>
      <label for="offerAmount">Offer Amount ($ADRIAN):</label>
      <input type="number" id="offerAmount" placeholder="1000.00" step="any" />
    </div>
    <button id="makeOfferButton">Make Offer</button>
    <hr />

    <!-- Sección: Ver Todas las Ofertas -->
    <h2>All Offers</h2>
    <button id="loadAllOffersButton">Load All Offers</button>
    <div id="offersList">
      <!-- Se mostrará la tabla con todas las ofertas -->
    </div>

    <script>
      // Dirección del contrato NFTMarketplace y token $ADRIAN
      const marketplaceAddress = "0x424A2456cC04724508f2bDb11B572d79dA1fA244";
      const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
      // La colección (Adriangallery) es fija
      const collectionAddress = "0xa92a8F5A47efC77da796dfD0827D07872E7D0429";

      // ABIs mínimos para las interacciones
      const marketplaceAbi = [
        "function makeOffer(uint256 listingId, uint256 offerAmount) external",
        "function acceptOffer(uint256 listingId, address buyer) external",
        "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
        "function listingIdCounter() external view returns (uint256)",
        "event OfferMade(uint256 indexed listingId, address indexed buyer, uint256 offerAmount)"
      ];
      const erc20Abi = [
        "function allowance(address owner, address spender) external view returns (uint256)",
        "function approve(address spender, uint256 amount) external returns (bool)"
      ];
      const erc1155Abi = [
        "function uri(uint256 tokenId) external view returns (string)"
      ];

      let provider, signer, signerAddress;
      let marketplaceContract, tokenContract;

      // Conectar Wallet
      document.getElementById("connectButton").addEventListener("click", async () => {
        if (window.ethereum) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum);
            await window.ethereum.request({ method: "eth_requestAccounts" });
            signer = provider.getSigner();
            signerAddress = await signer.getAddress();
            marketplaceContract = new ethers.Contract(marketplaceAddress, marketplaceAbi, signer);
            tokenContract = new ethers.Contract(tokenAddress, erc20Abi, signer);
            document.getElementById("walletStatus").innerText = "Wallet connected: " + signerAddress;
            loadActiveListings();
          } catch (err) {
            console.error(err);
            alert("Error connecting wallet: " + err.message);
          }
        } else {
          alert("Please install MetaMask");
        }
      });

      // Helpers para conversión de cantidades
      function toWei(amount) {
        return ethers.utils.parseUnits(amount.toString(), 18);
      }
      function fromWei(amount) {
        return parseFloat(ethers.utils.formatUnits(amount, 18)).toFixed(2);
      }

      // Cargar listados activos del marketplace
      async function loadActiveListings() {
        if (!marketplaceContract) {
          console.warn("Marketplace contract not defined. Connect wallet first.");
          return;
        }
        const offerSelector = document.getElementById("offerListingSelector");
        offerSelector.innerHTML = "";
        try {
          const counter = await marketplaceContract.listingIdCounter();
          for (let i = 1; i <= counter; i++) {
            try {
              const listing = await marketplaceContract.listings(i);
              if (
                listing.seller !== ethers.constants.AddressZero &&
                (Date.now() / 1000) <= listing.expirationTime.toNumber()
              ) {
                // Obtener el nombre del token desde la colección Adriangallery
                let tokenName = "Token #" + listing.tokenId;
                try {
                  const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, provider);
                  let tokenUri = await nftContract.uri(listing.tokenId);
                  tokenUri = tokenUri.replace("{id}", listing.tokenId.toString());
                  const response = await fetch(tokenUri);
                  const metadata = await response.json();
                  if (metadata.name) {
                    tokenName = metadata.name;
                  }
                } catch (e) {
                  console.log("Error fetching metadata for listing", i, e);
                }
                const option = document.createElement("option");
                option.value = listing.id;
                option.text = `Listing ${listing.id} - ${tokenName}`;
                offerSelector.appendChild(option);
              }
            } catch (err) {
              console.error("Error fetching listing", i, err);
            }
          }
          if (offerSelector.options.length === 0) {
            offerSelector.innerHTML = "<option>No active listings</option>";
          }
        } catch (err) {
          console.error("Error loading listings:", err);
        }
      }

      // Hacer Oferta
      document.getElementById("makeOfferButton").addEventListener("click", async () => {
        try {
          if (!signer) {
            alert("Please connect your wallet first.");
            return;
          }
          const listingId = document.getElementById("offerListingSelector").value;
          const offerInput = document.getElementById("offerAmount").value;
          if (!offerInput || isNaN(offerInput)) {
            alert("Enter a valid offer amount.");
            return;
          }
          const offerAmount = toWei(offerInput);
          // Verificar allowance del token ERC20
          const allowance = await tokenContract.allowance(signerAddress, marketplaceAddress);
          if (allowance.lt(offerAmount)) {
            const approveTx = await tokenContract.approve(marketplaceAddress, offerAmount);
            await approveTx.wait();
            console.log("ERC20 token approved for marketplace.");
          }
          const txOffer = await marketplaceContract.makeOffer(listingId, offerAmount);
          await txOffer.wait();
          alert("Offer made successfully!");
          loadActiveListings();
        } catch (err) {
          console.error(err);
          alert("Error making offer: " + err.message);
        }
      });

      // Cargar y mostrar TODAS las ofertas de todos los listados
      document.getElementById("loadAllOffersButton").addEventListener("click", async () => {
        if (!marketplaceContract) {
          alert("Please connect your wallet first.");
          return;
        }
        try {
          const offersListDiv = document.getElementById("offersList");
          offersListDiv.innerHTML = "Loading offers...";
          const filter = marketplaceContract.filters.OfferMade();
          const events = await marketplaceContract.queryFilter(filter);
          if (events.length === 0) {
            offersListDiv.innerHTML = "<p>No offers available at the moment.</p>";
            return;
          }
          let html = "<table><tr><th>Listing ID</th><th>Token Name</th><th>Buyer</th><th>Offer Amount ($ADRIAN)</th><th>Action</th></tr>";
          for (let event of events) {
            const listingId = event.args.listingId;
            const buyer = event.args.buyer;
            const rawOffer = event.args.offerAmount;
            const offerFormatted = fromWei(rawOffer);
            let tokenName = "Token #" + listingId;
            try {
              const listing = await marketplaceContract.listings(listingId);
              try {
                const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, provider);
                let tokenUri = await nftContract.uri(listing.tokenId);
                tokenUri = tokenUri.replace("{id}", listing.tokenId.toString());
                const response = await fetch(tokenUri);
                const metadata = await response.json();
                if (metadata.name) {
                  tokenName = metadata.name;
                }
              } catch (e) {
                console.log("Error fetching metadata for listing", listingId, e);
              }
            } catch (e) {
              console.log("Error fetching listing details for", listingId, e);
            }
            html += `<tr>
                        <td>${listingId}</td>
                        <td>${tokenName}</td>
                        <td>${buyer}</td>
                        <td>${offerFormatted}</td>
                        <td><button onclick="acceptOffer(${listingId},'${buyer}')">Accept Offer</button></td>
                     </tr>`;
          }
          html += "</table>";
          offersListDiv.innerHTML = html;
        } catch (err) {
          console.error(err);
          alert("Error loading offers: " + err.message);
        }
      });

      // Función para aceptar una oferta
      async function acceptOffer(listingId, buyer) {
        try {
          if (!signer) {
            alert("Please connect your wallet first.");
            return;
          }
          // El vendedor debe aprobar el NFT si aún no está aprobado
          const listing = await marketplaceContract.listings(listingId);
          const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, signer);
          const isApproved = await nftContract.isApprovedForAll(signerAddress, marketplaceAddress);
          if (!isApproved) {
            const approvalTx = await nftContract.setApprovalForAll(marketplaceAddress, true);
            await approvalTx.wait();
            console.log("NFT collection approved for marketplace.");
          }
          const tx = await marketplaceContract.acceptOffer(listingId, buyer);
          await tx.wait();
          alert("Offer accepted successfully!");
          loadActiveListings();
        } catch (err) {
          console.error(err);
          alert("Error accepting offer: " + err.message);
        }
      }
    </script>
  </body>
</html>

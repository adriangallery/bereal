<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>NFT Marketplace Offers</title>
    <!-- Favicon para evitar errores 404 -->
    <link rel="icon" href="data:,">
    <!-- Carga ethers.js desde un CDN confiable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      h1, h2 { color: #333; }
      input, select, button { margin: 5px 0; padding: 5px; }
      table { border-collapse: collapse; margin-top: 10px; }
      table, th, td { border: 1px solid #ccc; padding: 8px; }
    </style>
  </head>
  <body>
    <h1>NFT Marketplace Offers</h1>
    <button id="connectButton">Connect Wallet</button>
    <p id="walletStatus">Wallet not connected</p>
    <hr />

    <!-- Sección: Crear Listado -->
    <h2>Create Listing</h2>
    <div>
      <label for="nftCollection">NFT Collection Address:</label>
      <!-- Se asigna por defecto la dirección de Adriangallery -->
      <input type="text" id="nftCollection" value="0xa92a8F5A47efC77da796dfD0827D07872E7D0429" size="42" />
      <button id="loadUserNFTsButton">Load My NFTs</button>
    </div>
    <div>
      <label for="nftTokenSelector">Select NFT (by name):</label>
      <select id="nftTokenSelector">
        <!-- Se llenará dinámicamente con los NFTs que posee el usuario -->
      </select>
    </div>
    <div>
      <label for="quantity">Quantity:</label>
      <input type="number" id="quantity" value="1" min="1" />
    </div>
    <div>
      <label for="listingPrice">Price ($ADRIAN):</label>
      <!-- Campo numérico: el usuario ingresa un número normal -->
      <input type="number" id="listingPrice" placeholder="1000.00" step="any" />
    </div>
    <div>
      <label for="duration">Duration:</label>
      <select id="duration">
        <option value="3600">1 Hour</option>
        <option value="86400">1 Day</option>
        <option value="604800">7 Days</option>
        <option value="2592000">1 Month</option>
        <option value="15552000">6 Months</option>
      </select>
    </div>
    <button id="createListingButton">Create Listing</button>
    <hr />

    <!-- Sección: Hacer Oferta -->
    <h2>Make Offer</h2>
    <div>
      <label for="offerListingSelector">Select Listing:</label>
      <!-- Se cargará dinámicamente con listados activos mostrando el nombre del NFT -->
      <select id="offerListingSelector">
        <!-- Opciones llenadas dinámicamente -->
      </select>
    </div>
    <div>
      <label for="offerAmount">Offer Amount ($ADRIAN):</label>
      <input type="number" id="offerAmount" placeholder="1000.00" step="any" />
    </div>
    <button id="makeOfferButton">Make Offer</button>
    <hr />

    <!-- Sección: Ver Todas las Ofertas -->
    <h2>All Offers</h2>
    <button id="loadAllOffersButton">Load All Offers</button>
    <div id="offersList">
      <!-- Aquí se mostrará la tabla con todas las ofertas -->
    </div>

    <script>
      // Direcciones de contratos: reemplaza según tu despliegue
      const marketplaceAddress = "0xYourMarketplaceAddress"; // Dirección del marketplace
      const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea"; // Dirección del token $ADRIAN

      // ABIs mínimos para las interacciones
      const marketplaceAbi = [
        "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration) external",
        "function makeOffer(uint256 listingId, uint256 offerAmount) external",
        "function acceptOffer(uint256 listingId, address buyer) external",
        "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
        "function listingIdCounter() external view returns (uint256)",
        "event ListingCreated(uint256 indexed listingId, address indexed seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)",
        "event OfferMade(uint256 indexed listingId, address indexed buyer, uint256 offerAmount)"
      ];
      const erc20Abi = [
        "function allowance(address owner, address spender) external view returns (uint256)",
        "function approve(address spender, uint256 amount) external returns (bool)"
      ];
      const erc1155Abi = [
        "function isApprovedForAll(address account, address operator) external view returns (bool)",
        "function setApprovalForAll(address operator, bool approved) external",
        "function balanceOf(address account, uint256 id) external view returns (uint256)",
        "function uri(uint256 tokenId) external view returns (string)"
      ];

      let provider, signer, signerAddress;
      let marketplaceContract, tokenContract;
      let userNFTContract; // Para las interacciones con la colección NFT

      // Conexión del Wallet
      document.getElementById("connectButton").addEventListener("click", async () => {
        if (window.ethereum) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum);
            await window.ethereum.request({ method: "eth_requestAccounts" });
            signer = provider.getSigner();
            signerAddress = await signer.getAddress();
            marketplaceContract = new ethers.Contract(marketplaceAddress, marketplaceAbi, signer);
            tokenContract = new ethers.Contract(tokenAddress, erc20Abi, signer);
            document.getElementById("walletStatus").innerText = "Wallet connected: " + signerAddress;
            // Cargar listados activos para "Make Offer"
            loadActiveListings();
          } catch (err) {
            console.error(err);
            alert("Error connecting wallet: " + err.message);
          }
        } else {
          alert("Please install MetaMask");
        }
      });

      // Helpers para conversión de cantidades
      function toWei(amount) {
        return ethers.utils.parseUnits(amount.toString(), 18);
      }
      function fromWei(amount) {
        return parseFloat(ethers.utils.formatUnits(amount, 18)).toFixed(2);
      }

      // Cargar NFTs del usuario para "Create Listing"
      document.getElementById("loadUserNFTsButton").addEventListener("click", async () => {
        const collectionAddress = document.getElementById("nftCollection").value;
        if (!signer) {
          alert("Please connect your wallet first.");
          return;
        }
        userNFTContract = new ethers.Contract(collectionAddress, erc1155Abi, signer);
        const nftSelector = document.getElementById("nftTokenSelector");
        nftSelector.innerHTML = ""; // Limpiar opciones previas

        // Ejemplo: revisa token IDs del 1 al 10
        for (let tokenId = 1; tokenId <= 10; tokenId++) {
          try {
            const balance = await userNFTContract.balanceOf(signerAddress, tokenId);
            if (balance.gt(0)) {
              let tokenName = "Token #" + tokenId;
              try {
                let tokenUri = await userNFTContract.uri(tokenId);
                tokenUri = tokenUri.replace("{id}", tokenId.toString());
                const response = await fetch(tokenUri);
                const metadata = await response.json();
                if (metadata.name) {
                  tokenName = metadata.name;
                }
              } catch (e) {
                console.log("Error fetching metadata for token", tokenId, e);
              }
              const option = document.createElement("option");
              option.value = tokenId;
              option.text = tokenName;
              nftSelector.appendChild(option);
            }
          } catch (err) {
            console.error("Error checking token", tokenId, err);
          }
        }
        if (nftSelector.options.length === 0) {
          nftSelector.innerHTML = "<option>No NFTs found</option>";
        }
      });

      // Crear Listado
      document.getElementById("createListingButton").addEventListener("click", async () => {
        try {
          if (!signer) {
            alert("Please connect your wallet first.");
            return;
          }
          const collectionAddress = document.getElementById("nftCollection").value;
          const tokenId = document.getElementById("nftTokenSelector").value;
          const quantity = document.getElementById("quantity").value;
          const priceInput = document.getElementById("listingPrice").value;
          const duration = document.getElementById("duration").value;
          if (!priceInput || isNaN(priceInput)) {
            alert("Enter a valid price.");
            return;
          }
          const price = toWei(priceInput);

          // Verificar que la colección NFT esté aprobada para el marketplace
          const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, signer);
          const isApproved = await nftContract.isApprovedForAll(signerAddress, marketplaceAddress);
          if (!isApproved) {
            const approvalTx = await nftContract.setApprovalForAll(marketplaceAddress, true);
            await approvalTx.wait();
            console.log("NFT collection approved for marketplace.");
          }

          const tx = await marketplaceContract.createListing(collectionAddress, tokenId, quantity, price, duration);
          await tx.wait();
          alert("Listing created successfully!");
          loadActiveListings();
        } catch (err) {
          console.error(err);
          alert("Error creating listing: " + err.message);
        }
      });

      // Cargar listados activos para el selector en "Make Offer"
      async function loadActiveListings() {
        if (!marketplaceContract) {
          console.warn("Marketplace contract not defined. Connect wallet first.");
          return;
        }
        const offerSelector = document.getElementById("offerListingSelector");
        offerSelector.innerHTML = "";
        try {
          const counter = await marketplaceContract.listingIdCounter();
          for (let i = 1; i <= counter; i++) {
            try {
              const listing = await marketplaceContract.listings(i);
              // Verifica que el listado exista y no esté expirado
              if (
                listing.seller !== ethers.constants.AddressZero &&
                (Date.now() / 1000) <= listing.expirationTime.toNumber()
              ) {
                let tokenName = "Token #" + listing.tokenId;
                const nftContract = new ethers.Contract(listing.collection, erc1155Abi, provider);
                try {
                  let tokenUri = await nftContract.uri(listing.tokenId);
                  tokenUri = tokenUri.replace("{id}", listing.tokenId.toString());
                  const response = await fetch(tokenUri);
                  const metadata = await response.json();
                  if (metadata.name) {
                    tokenName = metadata.name;
                  }
                } catch (e) {
                  console.log("Error fetching metadata for listing", i, e);
                }
                const option = document.createElement("option");
                option.value = listing.id;
                option.text = `Listing ${listing.id} - ${tokenName}`;
                offerSelector.appendChild(option);
              }
            } catch (err) {
              console.error("Error fetching listing", i, err);
            }
          }
          if (offerSelector.options.length === 0) {
            offerSelector.innerHTML = "<option>No active listings</option>";
          }
        } catch (err) {
          console.error("Error loading listings:", err);
        }
      }

      // Hacer Oferta
      document.getElementById("makeOfferButton").addEventListener("click", async () => {
        try {
          if (!signer) {
            alert("Please connect your wallet first.");
            return;
          }
          const listingId = document.getElementById("offerListingSelector").value;
          const offerInput = document.getElementById("offerAmount").value;
          if (!offerInput || isNaN(offerInput)) {
            alert("Enter a valid offer amount.");
            return;
          }
          const offerAmount = toWei(offerInput);

          // Verificar allowance del token ERC20
          const allowance = await tokenContract.allowance(signerAddress, marketplaceAddress);
          if (allowance.lt(offerAmount)) {
            const approveTx = await tokenContract.approve(marketplaceAddress, offerAmount);
            await approveTx.wait();
            console.log("ERC20 token approved for marketplace.");
          }

          const txOffer = await marketplaceContract.makeOffer(listingId, offerAmount);
          await txOffer.wait();
          alert("Offer made successfully!");
          loadActiveListings();
        } catch (err) {
          console.error(err);
          alert("Error making offer: " + err.message);
        }
      });

      // Cargar y mostrar TODAS las ofertas (de todos los listados)
      document.getElementById("loadAllOffersButton").addEventListener("click", async () => {
        if (!marketplaceContract) {
          alert("Please connect your wallet first.");
          return;
        }
        try {
          const offersListDiv = document.getElementById("offersList");
          offersListDiv.innerHTML = "Loading offers...";
          const filter = marketplaceContract.filters.OfferMade();
          const events = await marketplaceContract.queryFilter(filter);
          if (events.length === 0) {
            offersListDiv.innerHTML = "<p>No offers available at the moment.</p>";
            return;
          }
          let html = "<table><tr><th>Listing ID</th><th>Token Name</th><th>Buyer</th><th>Offer Amount ($ADRIAN)</th><th>Action</th></tr>";
          for (let event of events) {
            const listingId = event.args.listingId;
            const buyer = event.args.buyer;
            const rawOffer = event.args.offerAmount;
            const offerFormatted = fromWei(rawOffer);
            let tokenName = "Token #" + listingId;
            try {
              const listing = await marketplaceContract.listings(listingId);
              const nftContract = new ethers.Contract(listing.collection, erc1155Abi, provider);
              try {
                let tokenUri = await nftContract.uri(listing.tokenId);
                tokenUri = tokenUri.replace("{id}", listing.tokenId.toString());
                const response = await fetch(tokenUri);
                const metadata = await response.json();
                if (metadata.name) {
                  tokenName = metadata.name;
                }
              } catch (e) {
                console.log("Error fetching metadata for listing", listingId, e);
              }
            } catch (e) {
              console.log("Error fetching listing details for", listingId, e);
            }
            html += `<tr>
                        <td>${listingId}</td>
                        <td>${tokenName}</td>
                        <td>${buyer}</td>
                        <td>${offerFormatted}</td>
                        <td><button onclick="acceptOffer(${listingId},'${buyer}')">Accept Offer</button></td>
                     </tr>`;
          }
          html += "</table>";
          offersListDiv.innerHTML = html;
        } catch (err) {
          console.error(err);
          alert("Error loading offers: " + err.message);
        }
      });

      // Función para aceptar una oferta
      async function acceptOffer(listingId, buyer) {
        try {
          if (!signer) {
            alert("Please connect your wallet first.");
            return;
          }
          const listing = await marketplaceContract.listings(listingId);
          const collectionAddress = listing.collection;
          const nftContract = new ethers.Contract(collectionAddress, erc1155Abi, signer);
          const isApproved = await nftContract.isApprovedForAll(signerAddress, marketplaceAddress);
          if (!isApproved) {
            const approvalTx = await nftContract.setApprovalForAll(marketplaceAddress, true);
            await approvalTx.wait();
            console.log("NFT collection approved for marketplace.");
          }
          const tx = await marketplaceContract.acceptOffer(listingId, buyer);
          await tx.wait();
          alert("Offer accepted successfully!");
          loadActiveListings();
        } catch (err) {
          console.error(err);
          alert("Error accepting offer: " + err.message);
        }
      }
    </script>
  </body>
</html>
